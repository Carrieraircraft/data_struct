// MyProject.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
//公众号：程序员速成 ，内含一辈子都让你感激自己的优质视频教程，欢迎关注

#include <iostream>
#include  <assert.h>

#ifdef _DEBUG   //只在Debug（调试）模式下
#ifndef DEBUG_NEW
#define DEBUG_NEW new(_NORMAL_BLOCK,__FILE__,__LINE__) //重新定义new运算符
#define new DEBUG_NEW
#endif
#endif

//#include <boost/type_index.hpp>
using namespace std;
#pragma warning(disable : 4996) 
//#pragma warning(disable : 6386) 

//------------------------------
namespace _nmsp1
{
	//前序遍历伪代码：
	//void preOrder(BinaryTreeNode* tNode) //前序遍历二叉树
	//{
	//	if (tNode != nullptr) //若二叉树非空
	//	{
	//		//根左右
	//		visit(tNode); //根问根节点，比如输出节点数据域值
	//		preOrder(tNode->leftChild); //递归方式前序遍历左子树
	//		preOrder(tNode->rightChild); //递归方式前序遍历右子树
	//	}
	//}

	//中序遍历伪代码：
	//void inOrder(BinaryTreeNode* tNode) //中序遍历二叉树
	//{
	//	if (tNode != nullptr) //若二叉树非空
	//	{
	//		//左根右
	//		inOrder(tNode->leftChild); //递归方式中序遍历左子树
	// 	    visit(tNode); //根问根节点，比如输出节点数据域值
	//		inOrder(tNode->rightChild); //递归方式中序遍历右子树
	//	}
	//}
	
	//后序遍历伪代码：
	//void postOrder(BinaryTreeNode* tNode) //后序遍历二叉树
	//{
	//	if (tNode != nullptr) //若二叉树非空
	//	{
	//		//左右根	
	//		postOrder(tNode->leftChild); //递归方式后序遍历左子树	
	//		postOrder(tNode->rightChild); //递归方式后序遍历右子树
	// 	    visit(tNode); //根问根节点，比如输出节点数据域值
	//	}
	//}
}

int main()
{
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);//程序退出时检测内存泄漏并显示到“输出”窗口

	//第3章 树
	//第二节  二叉树
	//（1）基本概念
	//（2）特殊二叉树	
	//（3）二叉树的性质
	//（4）二叉树的遍历:根出发，依次访问二叉树所有节点。使每个节点都被访问且只被访问一次。
	  //经典遍历方式：前序、中序、后序遍历（深度优先搜索/深度优先【沿着每一个分支路径进行深入访问】遍历），面试常考。
	//（4.1）前序遍历、中序遍历、后序遍历基本概念
	//a)前序遍历：先序遍历/先根遍历。根开始，口诀：根左右。
	//b)中序遍历：中根遍历。根开始，口诀：左根右。
	//c)后序遍历：后根遍历。根开始，口诀：左右根。
	//（4.2）前序、中序、后序遍历简单范例
	 //满二叉树：前序：ABC  。中序：BAC  。后序：BCA。
	 //缺右子树的二叉树：前序：AB。中序：BA。后序：BA。
	 //缺左子树的二叉树：前序：AC。中序：AC。后序：CA。


	//（4.3）前序、中序、后序遍历针对3层满二叉树的遍历顺序范例
	//遍历，是递归。
	  //前序遍历：先访问根节点，再递归输出左子树，最后递归输出右子树（根左右）。
	  //中序遍历：先递归输出左子树，再输访问根节点，最后递归输出右子树（左根右）。
	  //后序遍历：先递归输出左子树，再递归输出右子树，最后输出访问根节点（左右根）。

	//前序遍历（根左右）：前两层   A    BDE   CFG
	//中序遍历（左根右）：前两层   DBE     A     FCG
	//后序遍历（左右根）：前两层   DEB     FGC     A

	//（4.4）前序、中序、后序遍历针对普通二叉树的遍历顺序范例及伪代码
	//前序：ABDGEHCF。
	   //   A    B   DG EH    CF
	//中序：DGBHEACF
	   //   DG  B  HE    A     CF
	//后序：GDHEBFCA
	   //   GD  HE   B     FC     A

	//（4.5）二叉树遍历的推导以及遍历的一些结论
	//结论一：已知中序、前序、后序、前序和后序遍历、是无法唯一确定一棵二叉树。
	//a)已知中序遍历，无法唯一确定一棵二叉树。BADCE
	//b)已知前序遍历，无法唯一确定一棵二叉树。BADCE
	//c)已知后序遍历，无法唯一确定一棵二叉树。BADCE
	//d)已知前序和后序遍历，无法唯一确定一棵二叉树。前序：ABCD。后序：DCBA

	//结论二：已知 前序和中序遍历，或者已知 中序和后序 遍历序列，是能够唯一确定一棵二叉树的。
	//已知一棵二叉树 前序遍历序列  ABCDEF，中序遍历序列CBAEDF。
	//a)根：A
	//b)根据中序 CBAEDF，可以知道C,B是根节点A的左子树中的节点,EDF是根节点A右子树中的节点。
	//c)根据前序和中序序列，A的左子树就绘制出来了。
	//d)根据前序和中序序列，A的右子树就绘制出来了。
	//上述唯一确定了一棵二叉树。则就可以得到该二叉树的后序遍历序列了CBEFDA。

	//总结根据给定的遍历序列确定一个二叉树的方法：
	//a）找到树根。
	//b）根据中序遍历序列划分左子树和右子树
	//c）进一步找到左右子树根节点以及分支和叶子节点。


	






	
	return 0;
}

// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧: 
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件


