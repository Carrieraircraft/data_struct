// MyProject.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
//公众号：程序员速成 ，内含一辈子都让你感激自己的优质视频教程，欢迎关注


#include <iostream>
#include <list>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <assert.h>
#include <sstream>
#include <stack>

#pragma warning (disable: 4996) 
using namespace std;



int main()
{	
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);//程序退出时检测内存泄漏并显示到“输出”窗口

	//第4章 图
	//第一节 图的基本概念、术语
	//第二节 图的存储结构及基本操作
	//第三节 图的应用之最小生成树
	//生成树：一个无向连通图的生成树是包含图中全部顶点的一个极小连通子图。
	//最小生成树：对于一个带权无向连通图，其生成树不同，树中所有边上的权值之和也可能不同，
		//边上权值之和最小的生成树就是该带权连通无向图的最小生成树（Minimum Spanning Tree：MST）。
	//（1）普里姆（Prim）算法
	//时间复杂度：O(|V|^2)， O(n^2)。
	//顶点数比较少，边数比较多时该算法构造最小生成树效果比较好。 
	//（2）克鲁斯卡尔（Kruskal）算法:挑选出权值最小的一条边。前提是a)这条边以往没被挑选过b)该边对应的两个顶点没有连通。
	//如果采用WeightSort排序，则排序算法的时间复杂度可能达到O(|E|^2)。
	 //如果采用qsort排序，则排序算法的时间复杂度为O(|E|log|E|)。
	//并查集判断两个顶点是否属于同一个集合，最坏时间复杂度O(Log|V|)。整个while循环时间复杂度O(|V|Log|V|)。
	//采用qsort算法，整个克鲁斯卡尔算法的时间复杂度O(|E|log|E| + |V|Log|V|)
	//图中顶点数比较多，边数比较少时使用该算法构造最小生成树效果比较好。
	//第四节 图的应用之最短路径
	//最短路径：指的是图中两个顶点之间经过的边上权值之和最小的路径
	//（1）迪杰斯特拉（Dijkstra）算法
	//思路1：a)设置一个集合S用于存放已经找到最短路径的顶点。S={A}
	//      b)设置一个叫dist的数组，元素数量等同于图中顶点数量。该数组用于存放当前起始点到其他各个顶点的最短距离（权值最小）,
			  //开始时该数组内容就是就是图4.4_2中源顶点 A所在行的值即{0，22，∞，6，∞,∞}
	//      c)设置一个叫path的数组，元素数量等同于图中顶点数量。该数组用于记录每个顶点在最短路径上的前趋节点，其内容需要根据dist
	          //中的内容得出。dist中对应下标位置是0或者∞，path对应位置是-1，dist中对应下标位置有权值则path对应位置是源顶点的下标。
	          //所以，开始时该数组内容为{-1，0，-1，0，-1，-1}；
	//思路2：开始计算从源顶点A到不在集合S中的顶点的最短路径。
	//    选择A->D，距离是6。并把顶点D放入集合S中表示源顶点A到顶点D的最短路径已经找到）。
	//    S={A,D}
	//    更新后的dist数组{0，16，26，6，∞,∞}，path={-1，3，3，0，-1，-1}

	//整理一下源顶点到其他顶点的距离
	//A->B=16（A->D->B），A->C=26（A->D-C），A->D=6，A->E=∞,A->F=∞;
	//选中A->B=16（A->D->B）,把顶点B放入集合S中：
	//     S={A,D,B}

	//A->E = 6+10+100=116(A->D->B->E路径)
	//dist数组{ 0，16，26，6，116,∞ }
	//path={-1，3，3，0，1，-1}

	//整理一下源顶点到其他顶点的距离
	//A->B=16（A->D->B）,A->C=26（A->D-C），A->D=6，A->E=116(A->D->B->E路径),A->F=∞
	//A->C=26（A->D->C）,把顶点C放入到集合S中：
	//     S={A,D,B,C}
	//A->E = 6+20+40=66（A->D->C->E）
	//A->F = 6+20+10=36(A-D->C->F)
	//dist数组{ 0，16，26，6，66,36 }
	//path={-1，3，3，0，2，2}

	//整理一下源顶点到其他顶点的距离
	//A->B=16（A->D->B）,A->C=26（A->D-C），A->D=6，A->E=66(A->D->C->E路径),A->F=36(A->D->C->F路径)
	//A->F = 36(A->D->C->F路径)
	//     S={A,D,B,C,F}
	//A->E=71 (A->D->C->F->E路径)
	//dist数组{ 0，16，26，6，66,36 }
	//path={-1，3，3，0，2，2}

	//整理一下源顶点到其他顶点的距离
	//A->B=16（A->D->B）,A->C=26（A->D-C），A->D=6，A->E=66(A->D->C->E路径),A->F=36(A->D->C->F路径)
	//A->E=66(A->D->C->E路径)
	//     S={A,D,B,C,F,E}

	//在增加了顶点E到集合后，顶点A（经过顶点E）到其他所有顶点是不是有更短的路径存在呢？没有了，因为顶点E没有到达任何其他顶点。
	//至此，集合S中已经包含了图中所有顶点，所以缔结斯特拉算法结束，此时：
	//dist数组{ 0，16，26，6，66,36 }
	//path={-1，3，3，0，2，2}
	
	//结果：
	//a)如何得到从源顶点A到顶点B的最短路径长度？
	//b)如何得到从源顶点A到顶点E的最短路径长度？





}


// 运行程序: Ctrl + F5 或调试 >“开始执行(不调试)”菜单
// 调试程序: F5 或调试 >“开始调试”菜单

// 入门使用技巧:  ∞
//   1. 使用解决方案资源管理器窗口添加/管理文件
//   2. 使用团队资源管理器窗口连接到源代码管理
//   3. 使用输出窗口查看生成输出和其他消息
//   4. 使用错误列表窗口查看错误nm,
//   5. 转到“项目”>“添加新项”以创建新的代码文件，或转到“项目”>“添加现有项”以将现有代码文件添加到项目
//   6. 将来，若要再次打开此项目，请转到“文件”>“打开”>“项目”并选择 .sln 文件



